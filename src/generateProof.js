const path = require("path");
const { exit } = require("process");
const snarkjs = require("snarkjs");
const utils = require("./utils")

let solution = 'word';
let guess = 'wokd';
let gameIdentifier = utils.generateRandomNumber();



const tree = utils.setupMerkleTree(solution, gameIdentifier)
const stringTree = utils.saveTreeToDB(tree)
const regenTree = utils.getTree(32, stringTree)
console.log('stringTree', stringTree)
console.log('regenTree', regenTree)
console.log('tree', tree)
console.log('leaves',regenTree.leaves)
console.log('root',tree.root)
const proofs = utils.generateGuessProofs(tree, guess, gameIdentifier)
const regenProofs = utils.generateGuessProofs1(regenTree, guess, gameIdentifier)
console.log('proofs', proofs)
console.log('regenProofs', regenProofs)

console.log(proofs == regenProofs)

const clue = utils.generateClue(tree, gameIdentifier, guess)
console.log('proofs', clue)

const createInput = (guess, gameIdentifier, clue, root, guessProofs) => {
  // root is gotten from merkle tree (can be on chain / assumed that tree is public to players) root stored on chain, tree stored in db, tree can be gotten by user using the root. root becomes unique identifier for game
  // clue is generated by gamemaster
  // game identifier is unique secret identifier for each game. Allows same word to be solution for different games
  // guess is player's guess
  // guess proofs are public, contain path indices and siblings for corresponsing leaf index in tree

  let letterIdentifier = [];
  let treePathIndices = [];
  let treeSiblings = [];
  for (const letter of guess) {
    letterIdentifier.push(utils.hashInput(letter))
  }

  for (const proof of guessProofs) {
    treePathIndices.push(proof.pathIndices)
    treeSiblings.push(proof.siblings)
  }
  
  return {  
    letterIdentifier,
    gameIdentifier,
    clue,
    treePathIndices,
    treeSiblings,
    root
  }
}

const input = createInput(guess, gameIdentifier, clue, tree.root, proofs)
console.log(input.treeSiblings)

const generateAcutalProof = async (input) => {
  const { proof, publicSignals } = await snarkjs.groth16.fullProve(
    input,
    path.join(__dirname, "..", "zk", "wordle_js", "wordle.wasm"),
    path.join(__dirname, "..", "zk", "zkey", "wordle_final.zkey"),
  );
  
  // const vKey = JSON.parse(fs.readFileSync(path.join(__dirname, "..", "zk", "wordle_verification_key.json")));

  // const res = await snarkjs.groth16.verify(vKey, publicSignals, proof);

  // if (res === true) {
  //     console.log("Verification OK");
  // } else {
  //     console.log("Invalid proof");
  // }
  console.log(publicSignals)
  return proof
}

generateAcutalProof(input).then((proof) => {
  console.log(proof)
  exit(0)
})



const generateGuessProofs = (tree, guess, gameIdentifier) => {
  let proofs = []
  for (let i = 0; i < tree.leaves.length; i++) {
    const proof = tree.createProof(tree.indexOf(tree.leaves[i]))
    proof.leaf = generateCommitment(hashInput(guess[i]), gameIdentifier)
    proofs[i] = proof
  }
  return proofs
}


